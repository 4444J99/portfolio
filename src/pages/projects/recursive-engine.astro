---
import Layout from '../../layouts/Layout.astro';
import Header from '../../components/Header.astro';
import Footer from '../../components/Footer.astro';
import ProjectDetail from '../../components/ProjectDetail.astro';
import SketchContainer from '../../components/sketches/SketchContainer.astro';
---

<Layout title="Recursive Engine (RE:GE) — 4444j" description="A symbolic operating system for myth and narrative — 21 organ handlers, a ritual syntax DSL, and 1,254 tests.">
  <Header />
  <main>
    <ProjectDetail
      title="Recursive Engine (RE:GE)"
      tagline="A symbolic operating system for myth and narrative"
      tags={['Theory', 'Python', 'DSL']}
      repo="https://github.com/organvm-i-theoria/recursive-engine--generative-entity"
    >
      <h2>The Question</h2>
      <p>
        Every software system tells a story — user flows are plot arcs, state machines are character development, error handling is conflict resolution. We treat these as metaphors. I wanted to find out what happens when you treat them as engineering principles. What if narrative structure, from Aristotle through Propp, could be encoded as executable rules? Not an AI that "writes stories" — a symbolic operating system where narrative principles govern how systems organize and evolve.
      </p>

      <h2>What RE:GE Does</h2>
      <p>
        RE:GE is a pure Python engine where <strong>myths, identities, rituals, and recursive structures are first-class computational objects</strong>. It implements 21 organ handlers that process symbolic values through a ritual syntax DSL:
      </p>
      <ul>
        <li><strong>Myth organs</strong> — encode narrative archetypes as transformation rules. A hero's journey is a function: entity state in, transformed state out.</li>
        <li><strong>Identity organs</strong> — manage how entities maintain coherence across transformations. When a character "changes," what persists?</li>
        <li><strong>Ritual organs</strong> — define sequences that must execute in order, with pre/post-conditions. Ceremonies as transactions.</li>
        <li><strong>Recursive organs</strong> — handle self-reference: entities that describe themselves, systems that modify their own rules.</li>
      </ul>

      <SketchContainer
        sketchId="recursive-tree"
        height="500px"
        mobileHeight="300px"
        ariaLabel="Interactive recursive syntax tree: branches grow upward, typed by DSL element (INVOKE, BINDING, WHEN). Some branches curve back into the trunk, visualizing recursion. Mouse guides growth direction. Click triggers recursion fold-back with DSL fragment display."
      />

      <h2>The Ritual Syntax</h2>
      <p>
        The engine parses and executes a domain-specific language for declaring symbolic operations:
      </p>
      <pre><code>INVOKE myth.hero_journey ON entity:protagonist
  WITH threshold: 0.7
  BINDING outcome TO identity.transform
  WHEN condition.readiness EXCEEDS threshold</code></pre>
      <p>
        This isn't pseudo-code. It's the actual syntax the engine parses and executes. The tree visualization above maps branch types to these DSL elements.
      </p>

      <h2>Testing the Untestable</h2>
      <p>
        The hardest part wasn't building the engine — it was proving it worked. When your system formalizes narrative, how do you write assertions? We found three strategies:
      </p>
      <p>
        <strong>Structural invariants (~400 tests)</strong> — An identity transformation must preserve entity type. A ritual must execute all steps or none. A recursive invocation must terminate within bounded depth.
      </p>
      <p>
        <strong>Reference implementations (~500 tests)</strong> — Propp's 31 functions, Campbell's monomyth stages, Aristotle's six elements encoded as test cases. If the engine claims to implement "Villainy," we verify the correct state transition.
      </p>
      <p>
        <strong>Round-trip consistency (~350 tests)</strong> — Serialize to DSL, parse back, verify identity. Apply transformation and inverse, verify return to original state.
      </p>
      <p>
        Result: <strong>1,254 tests, 85% line coverage</strong>.
      </p>

      <h2>Why Symbolic, Not Neural</h2>
      <p>
        <strong>Interpretability.</strong> Every transformation has a trace — which organ fired, what rule applied. As AI systems become more consequential, auditable narrative decisions matter.
      </p>
      <p>
        <strong>Composability.</strong> Build a myth organ on top of an identity organ on top of a recursive organ. Swap organs in and out. LLMs don't compose this way.
      </p>
      <p>
        <strong>Governance integration.</strong> RE:GE lives within the eight-organ system. Dependency validation, promotion state machine, monthly audits — narrative computation within an institutional framework.
      </p>

      <h2>The Discovery</h2>
      <p>
        The most surprising outcome wasn't technical — it was aesthetic. Having 21 distinct organ types with formal interfaces created <em>more</em> creative possibilities than working without structure. When you know what an identity transformation guarantees, you can safely compose it with a myth transformation. Formalism enables creativity. That insight reshaped how I think about every system I build.
      </p>

      <h2>Tradeoffs & Lessons</h2>
      <ul>
        <li><strong>Symbolic vs. neural approaches</strong> — Every transformation has a trace: which organ fired, what rule applied. This interpretability comes at the cost of flexibility — LLMs can improvise narrative in ways a symbolic engine cannot. The tradeoff is worth it for systems where auditability matters more than novelty.</li>
        <li><strong>21 organ types — over-engineered?</strong> — Started with 5, grew to 21 as formal completeness demanded finer distinctions. Some organs handle edge cases that arise rarely. The decision to keep them separate prioritizes composability: each organ has a clean interface contract, so removing one doesn't cascade.</li>
        <li><strong>DSL complexity</strong> — The ritual syntax is powerful but has a learning curve. A simpler API (plain Python method calls) would lower the barrier to entry but lose the expressiveness of declaring symbolic operations declaratively.</li>
        <li><strong>Test strategy for narrative systems</strong> — Testing "correct narrative behavior" required inventing three distinct strategies (structural invariants, reference implementations, round-trip consistency). This was the hardest engineering challenge — and the most transferable insight.</li>
      </ul>

      <h2>By the Numbers</h2>
      <div class="stat-grid">
        <div class="stat">
          <div class="stat-value">1,254</div>
          <div class="stat-label">Tests</div>
        </div>
        <div class="stat">
          <div class="stat-value">85%</div>
          <div class="stat-label">Coverage</div>
        </div>
        <div class="stat">
          <div class="stat-value">21</div>
          <div class="stat-label">Organ Handlers</div>
        </div>
        <div class="stat">
          <div class="stat-value">4</div>
          <div class="stat-label">Organ Types</div>
        </div>
        <div class="stat">
          <div class="stat-value">DSL</div>
          <div class="stat-label">Ritual Syntax</div>
        </div>
        <div class="stat">
          <div class="stat-value">Python</div>
          <div class="stat-label">Pure</div>
        </div>
      </div>

    </ProjectDetail>
  </main>
  <Footer />
</Layout>

<script>
  import '../../components/sketches/sketch-loader';
</script>
